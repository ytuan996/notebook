### 线程安全

#### 1. 线程安全的相关概念

线程安全的代码，本质就是管理对状态的访问，而且是共享、可变的状态。一个对象的状态就是它的数据，存储在状态变量中；
共享：就是一个状态变量可以被多个线程访问；可变：就是变量的值在其生命周期内可变；线程安全的代码，就是在不可控制
的并发访问中保护这些可变的状态变量。

无论何时，只要多余一个线程访问状态变量，并且某个线程会写入、修改该变量，那么就需要同步控制。在Java中，首要的
同步机制是synchronized关键字，提供独占锁，还有volatile修饰的变量，保证了变量在多线程中的可见行。

#### 2. 什么是线程安全

当多个线程同时调用一个类时，不用考虑这些线程的运行环境和交替执行，并且不需要做额外的同步或者协调，该类仍然
可以正确的执行，那么该类就是线程安全的。因为线程安全的类封装了任何必要的同步，因此调用者不必关心。

无状态的对象永远是线程安全的

#### 3. 原子性

多个线程共享的变量，在每个线程中执行自增操作时， int count = 0; count++; 自增操作不是线程安全的，这是一个
"读-改-写"操作合集。

- 出现错误的可能性： 竞争条件

- 复合操作：将一个类似自增的操作合集封装为 原子性的复合操作

#### 4. 锁

虽然类中的每个有状态变量都是原子并安全的，但是变量间不是彼此独立的，互相依赖，那么在多线程中就会出现不正确的结果。
我们必须保证状态变量之间的依赖关系也是线程的，Java中使用锁的概念解决。

- 内部锁：强制原子性的内部锁 -> synchronized 块；包含两部分，锁引用的对象，同步的代码块；

synchronized 方法是对包含整个方法体代码块的简写；synchronized 方法的锁，就是该实例对象本身；(静态的 synchronized
方法从Class对象获取锁)。

```java

class Main {
    public synchronized void test() {
        // 该代码的锁就是 该实例对象本身，同步的代码块是整个方法
    }
    
    public static synchronized testStatic() {
        // 该代码的锁是 Main，同步的也是整个方法
    }
}
```

synchronized 在Java中是互斥锁，同一时间只有一个线程可以进入同步代码块，保证了同步块中的代码可以原子性的执行，
在并发中，原子性的含义是：一组语句作为单独的，不可分割的执行单元。

- 重进入：占有锁的当前线程，再次请求同样的锁会成功。

当前线程请求了多少次，那么就应该相应的释放多少次，否则将一直占有。可重入的设计主要是考虑到了Java中的继承，
否则，子类重写父类方法时，将会产生死锁。

```java

// 父类
public class SuperClass{
    public synchronized void doSomething() {
        
    }
}

// 子类
public class subClass extends  SuperClass{
    @Override
    public synchronized void doSomething() {
        
    }
}
```



#### 5. 使用锁来保护状态

- 对于可被多个线程访问的可变变量，每次访问都需要获得一把锁，那么该变量是被锁保护的。

- 每个可变的共享变量都需要一把唯一的锁来同步，而开发者，维护者必须清楚这个锁。

- 对于每个涉及多个变量的不变约束，都要使用同一把锁来同步所有的变量。

#### 6. 活跃度和性能

尽量减小同步代码块的范围