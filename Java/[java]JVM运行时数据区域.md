### JVM 运行时数据区域

![image](https://github.com/ytuan996/notebook/blob/master/image/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png?raw=true)

- 程序计数器

当前线程执行字节码的行号指示器，通过该计数器的值来选取下一条需要执行的指令；它是线程私有的，每个线程都有自己的
程序计数器。

- 虚拟机栈

也是线程私有的，它的声明周期与线程相同；虚拟机栈描述的是Java方法执行的内存模型，里面存储着局部变量表，局部变量表
存储着方法内的基本数据类型，对象类型(但是不是对象本身，而是对象所在的起始地址)。栈的局部变量表是在进入一个方法时确定的。

- 本地方法栈

与虚拟机栈的功能类似，但是它服务的对象是JVM使用的native方法。

- Java堆

Java堆是所有线程共享的内存区域，在虚拟机启动时创建，用于存储对象本身。所有的对象和数组都在堆分配内存。
通常我们会按照垃圾分代收集将堆分为新生代和老年代。从内存分配角度，可能为每个线程分配私有缓冲区。但是不管怎么划分，
都只是为了更好的利用这块最大的内存。Java堆可以处于物理上不连续的内存空间。

- 方法区

线程共享的内存区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译的代码等；也叫做"永久代"，可以使用垃圾回收
器像管理Java堆内存一样管理方法区；在JDK1.7中，将字符串常量池从方法区移出到native。

- 运行时常量池

是方法区的一部分，存储的是编译期生成的字面量和各种符号引用。

### 对象的创建

1. 当我们在程序中执行new时，首先检查是否能在常量池中定位到一个类符号引用，并检查该引用对应的类是否被加载、解析、
初始化，如果没有那么执行类的加载过程。

2. 类加载检查通过后，将为对象分配内存；根据垃圾收集器的收集算法不同，为对象分配内存的方式也不大相同：Serial、
Parnew等待压缩功能的收集器采用指针碰撞；而CMS这种基于标记-清除的算法则使用空闲列表。

3. 还需要考虑创建对象的线程安全问题；一般有两种方式，一种将为对象分配内存的工作同步处理；还有就是为每个线程
在堆上划分一个缓冲池，分配完毕之后在同步到堆中；

4. 在对象分配到内存空间之后，需要将分到的内存空间进行初始化为类型字段的零值(所以程序中实例字段不赋初值也可使用)；

5. 对该对象进行必要的设置，如将该对象是哪个类的实例，如何找到该类的元数据信息，哈希码，锁信息，GC年龄分代信息存储到对象头中；

6. 执行<init>过程，按照程序员的意愿开始执行代码的初始化过程。 

### 对象的内存布局

对象在内存中布局可分为三块：对象头、实例数据、对齐填充

- 对象头

对象头的数据包含了两部分：一是存储对象自身的运行时数据，如哈希码、锁信息、GC分代信息；二是类型指针，通过该指针确定
该对象是哪个类的实例。

- 实例数据

在代码中定义的各种类型字段， 符号引用；无论是父类继承的，还是子类定义的，搜、都需要记录下来。

- 对齐填充

起到占位符的作用

### 对象的访问定位

java程序需要通过栈上的引用数据来操作堆上具体的对象。

栈上的引用定位到具体的对象有两种方式：句炳访问和直接指针

- 句炳访问

需要在ava堆中划出一块内存来作为句炳，而栈上存储的就是句炳池的地址，在句炳中包含了类型数据和实例数据各自的具体地址。

- 直接指针

需要考虑如何在堆中放置类型数据，而栈上存储的就是对象所在的地址

在HOTSPOT虚拟机中使用的是直接指针的方式